import numpy as np
from sklearn.linear_model import LinearRegression

# --------- Scenario generator ----------
def generate_scenarios(T, M, rng, base_curve, sigma=4.0, mean_revert=0.4):
    P = np.zeros((T, M))
    for m in range(M):
        x = base_curve[0] + rng.normal(0, sigma)
        P[0, m] = max(0, x)
        for t in range(1, T):
            drift = mean_revert * (base_curve[t] - x)
            x += drift + rng.normal(0, sigma)
            P[t, m] = max(0, x)
    return P

def poly_features(p, degree=2):
    p = np.asarray(p).reshape(-1, 1)
    # [1, p, p^2, ...]
    return np.hstack([p**d for d in range(degree + 1)])

# --------- LSMC Battery Optimizer ----------
class LSMC_Battery:
    def __init__(self, T, R_max, eta_c, c_max, d_max, cycles,
                 day_len=24, NR=21, NA=21, degree=2):
        self.T = T
        self.R_max = float(R_max)
        self.eta_c = float(eta_c)        # charge efficiency (discharge lossless)
        self.c_max = float(c_max)
        self.d_max = float(d_max)
        self.cycles = int(cycles)
        self.day_len = int(day_len)
        self.degree = int(degree)
        self.R_grid = np.linspace(0.0, R_max, NR)
        self.action_grid = np.linspace(-d_max, c_max, NA)  # (-) discharge, (+) charge
        self.betas = [None] * T

    def daily_buy_cap(self):
        # total energy you may purchase in a day (grid energy) per your spec
        return self.cycles * self.R_max / self.eta_c

    import numpy as np
from numpy.polynomial.laguerre import lagval

def laguerre_features(p, R=None, degree=3, cross=True):
    """
    Generate Laguerre polynomial features for LSMC basis expansion.
    Optionally includes cross terms with state variable R.

    Parameters
    ----------
    p : array-like, shape (n,)
        Price variable.
    R : array-like, shape (n,), optional
        State variable (e.g. storage level).
    degree : int
        Maximum Laguerre polynomial degree.
    cross : bool
        Whether to include p–R interaction terms.

    Returns
    -------
    Φ : ndarray, shape (n, n_features)
        Feature matrix including Laguerre basis and cross terms.
    """
    p = np.asarray(p).reshape(-1)
    n = len(p)
    # Normalize prices to roughly [0, 1] for numerical stability
    p_scaled = p / (np.max(p) + 1e-9)
    coeffs = np.eye(degree + 1)
    Lp = np.column_stack([lagval(p_scaled, coeffs[d]) for d in range(degree + 1)])

    if R is None:
        return Lp

    R = np.asarray(R).reshape(-1)
    R_scaled = R / (np.max(R) + 1e-9)
    LR = np.column_stack([lagval(R_scaled, coeffs[d]) for d in range(degree + 1)])

    if not cross:
        return np.hstack([Lp, LR])

    # Cross terms: pairwise products Lp_i * LR_j
    cross_terms = np.column_stack([
        Lp[:, i] * LR[:, j]
        for i in range(1, degree + 1)
        for j in range(1, degree + 1)
    ])

    Φ = np.hstack([Lp, LR, cross_terms])
    return Φ


    # ---- Training (backward induction with regression) ----
    def fit(self, prices):
        T, M = prices.shape
        betas = [None] * T
        for t in reversed(range(T - 1)):
            P_t, P_tp1 = prices[t, :], prices[t + 1, :]
            betas_t = np.zeros((len(self.R_grid), self.degree + 1))
            for k, R_next in enumerate(self.R_grid):
                if t + 1 == T - 1:
                    # Next step is terminal: continuation is salvage at T
                    Y = prices[-1, :] * R_next
                else:
                    # Use continuation model learned for t+1 at R_next
                    Y = poly_features(P_tp1, self.degree) @ betas[t + 1][k]
                X = poly_features(P_t, self.degree)
                model = LinearRegression(fit_intercept=False)
                model.fit(X, Y)
                betas_t[k] = model.coef_
            betas[t] = betas_t
        # reuse penultimate step’s model for the last step
        betas[-1] = betas[-2].copy()
        self.betas = betas

    # ---- One-step greedy action from learned Q/continuation ----
    def decide(self, t, R, B, p):
        cap_buy  = min(self.c_max, B, (self.R_max - R) / self.eta_c)
        cap_sell = min(self.d_max, R)
        phi = poly_features([p], self.degree).ravel()

        best_val, best_a, best_Rn = -1e18, 0.0, R
        for a in self.action_grid:
            if a > 0 and a > cap_buy:   continue
            if a < 0 and -a > cap_sell: continue
            Rn = np.clip(R + self.eta_c * max(a, 0.0) - max(-a, 0.0), 0.0, self.R_max)
            # nearest bin for Rn (simple, fast)
            k = np.searchsorted(self.R_grid, Rn)
            k = np.clip(k, 0, len(self.R_grid) - 1)
            cont = float(self.betas[t][k] @ phi)
            reward = p * (max(-a, 0.0) - max(a, 0.0))
            val = reward + cont
            if val > best_val:
                best_val, best_a, best_Rn = val, a, Rn
        return best_a, best_Rn, best_val

    # ---- Evaluate policy on a set of paths ----
    def evaluate(self, prices):
        T, M = prices.shape
        profits = np.zeros(M)
        C_day = self.daily_buy_cap()
        for m in range(M):
            R, B, total = 0.0, C_day, 0.0
            for t in range(T):
                p = prices[t, m]
                a, Rn, _ = self.decide(t, R, B, p)
                total += p * (max(-a, 0.0) - max(a, 0.0))
                R = Rn
                B = max(0.0, B - max(a, 0.0))
                if (t + 1) % self.day_len == 0:
                    B = C_day  # daily reset
            # terminal salvage
            total += prices[-1, m] * R
            profits[m] = total
        return profits.mean(), profits

    # ---- Print a deterministic schedule (base curve) ----
    def print_schedule(self, base_curve, start_R=0.0):
        T = len(base_curve)
        R = float(start_R)
        B = self.daily_buy_cap()
        total = 0.0
        total_buy = 0.0
        total_sell = 0.0

        print("\nPolicy schedule along deterministic path:")
        print("t   Price    Action    Storage    Budget")
        for t in range(T):
            p = float(base_curve[t])
            a, Rn, _ = self.decide(t, R, B, p)
            total += p * (max(-a, 0.0) - max(a, 0.0))
            total_buy  += max(a, 0.0)
            total_sell += max(-a, 0.0)
            Bn = max(0.0, B - max(a, 0.0))
            print(f"{t:02d}  {p:6.2f}   {a:7.2f}   {Rn:8.2f}   {Bn:8.2f}")
            R, B = Rn, Bn
            if (t + 1) % self.day_len == 0:
                B = self.daily_buy_cap()

        # Salvage
        total += base_curve[-1] * R
        if R > 1e-9:
            print(f"** Terminal salvage of {R:.2f} at price {base_curve[-1]:.2f} adds {base_curve[-1]*R:.2f}")

        print(f"\nTotals — Buy: {total_buy:.2f}, Sell: {total_sell:.2f}, Profit: {total:.2f}")


# =============== Run ===============
if __name__ == "__main__":
    rng = np.random.default_rng(42)
    T = 24
    base = np.array([40,38,36,35,34,33,32,35,45,55,60,70,
                     65,58,52,48,46,44,43,42,41,40,39,38], float)

    # In-sample scenarios (stochastic) and out-of-sample (deterministic)
    prices_train = generate_scenarios(T, 3000, rng, base, sigma=4.0, mean_revert=0.4)
    prices_test  = generate_scenarios(T, 2000, rng, base, sigma=0.0, mean_revert=0.0)  # deterministic

    model = LSMC_Battery(
        T=T, R_max=100, eta_c=0.87,
        c_max=50, d_max=50, cycles=2,
        day_len=24, NR=21, NA=21, degree=2
    )

    # Train (in-sample), then evaluate (in-sample & out-of-sample)
    model.fit(prices_train)
    mean_in, _      = model.evaluate(prices_train)
    mean_out, profs = model.evaluate(prices_test.transpose())

    print(f"\nIn-sample mean profit:  {mean_in:.2f}")
    print(f"Out-of-sample mean:     {mean_out:.2f}")
    print(f"Out-of-sample std:      {np.std(profs):.2f}")

    # Print the deterministic schedule
    model.print_schedule(base_curve=base)
