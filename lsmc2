import numpy as np
from sklearn.linear_model import LinearRegression
from numpy.polynomial.laguerre import lagval


# ---------- Laguerre polynomial feature basis ----------
def laguerre_features(p, R, degree=3, cross=True):
    """
    Laguerre polynomial basis with optional cross terms between price (p) and storage (R).
    """
    p = np.asarray(p).reshape(-1)
    R = np.asarray(R).reshape(-1)
    p_scaled = p / (np.max(p) + 1e-9)
    R_scaled = R / (np.max(R) + 1e-9)

    coeffs = np.eye(degree + 1)
    Lp = np.column_stack([lagval(p_scaled, coeffs[d]) for d in range(degree + 1)])
    LR = np.column_stack([lagval(R_scaled, coeffs[d]) for d in range(degree + 1)])

    if not cross:
        return np.hstack([Lp, LR])

    cross_terms = np.column_stack([
        Lp[:, i] * LR[:, j]
        for i in range(1, degree + 1)
        for j in range(1, degree + 1)
    ])

    return np.hstack([Lp, LR, cross_terms])


# ---------- Price scenario generator ----------
def generate_scenarios(T, M, rng, base_curve, sigma=4.0, mean_revert=0.4):
    """Mean-reverting Gaussian price process."""
    P = np.zeros((T, M))
    for m in range(M):
        x = base_curve[0] + rng.normal(0, sigma)
        P[0, m] = max(0, x)
        for t in range(1, T):
            drift = mean_revert * (base_curve[t] - x)
            x += drift + rng.normal(0, sigma)
            P[t, m] = max(0, x)
    return P


# ---------- LSMC Battery Optimizer ----------
class LSMC_Battery:
    def __init__(self, T, R_max, eta_c, c_max, d_max, cycles,
                 day_len=24, NR=21, NA=21, degree=3):
        self.T = T
        self.R_max = float(R_max)
        self.eta_c = float(eta_c)
        self.c_max = float(c_max)
        self.d_max = float(d_max)
        self.cycles = int(cycles)
        self.day_len = int(day_len)
        self.degree = int(degree)
        self.R_grid = np.linspace(0.0, R_max, NR)
        self.action_grid = np.linspace(-d_max, c_max, NA)
        self.betas = [None] * T

    def daily_buy_cap(self):
        return self.cycles * self.R_max / self.eta_c

    # ---------- Fit (Backward induction) ----------
    def fit(self, prices):
        T, M = prices.shape
        betas = [None] * T

        for t in reversed(range(T - 1)):
            P_t, P_tp1 = prices[t, :], prices[t + 1, :]
            betas_t = None  # allocate later dynamically

            for k, R_next in enumerate(self.R_grid):
                # R for all scenarios at this storage grid point
                R_vec = np.full_like(P_t, self.R_grid[k])

                # Continuation target
                if t + 1 == T - 1:
                    Y = prices[-1, :] * R_next
                else:
                    phi_next = laguerre_features(P_tp1, R_vec, degree=self.degree, cross=True)
                    Y = phi_next @ betas[t + 1][k]

                # Regress continuation value on current (P_t, R_t)
                X = laguerre_features(P_t, R_vec, degree=self.degree, cross=True)
                model = LinearRegression(fit_intercept=False)
                model.fit(X, Y)

                # Allocate betas_t dynamically based on number of features
                if betas_t is None:
                    n_feat = model.coef_.shape[0]
                    betas_t = np.zeros((len(self.R_grid), n_feat))

                betas_t[k, :] = model.coef_

            betas[t] = betas_t

        # copy last stage coefficients
        betas[-1] = betas[-2].copy()
        self.betas = betas

    # ---------- Decision rule ----------
    def decide(self, t, R, B, p):
        cap_buy = min(self.c_max, B, (self.R_max - R) / self.eta_c)
        cap_sell = min(self.d_max, R)
        phi = laguerre_features([p], [R], degree=self.degree, cross=True).ravel()

        best_val, best_a, best_Rn = -1e18, 0.0, R
        for a in self.action_grid:
            if a > 0 and a > cap_buy:   continue
            if a < 0 and -a > cap_sell: continue
            Rn = np.clip(R + self.eta_c * max(a, 0.0) - max(-a, 0.0), 0.0, self.R_max)
            k = np.searchsorted(self.R_grid, Rn)
            k = np.clip(k, 0, len(self.R_grid) - 1)
            cont = float(self.betas[t][k] @ phi)
            reward = p * (max(-a, 0.0) - max(a, 0.0))
            val = reward + cont
            if val > best_val:
                best_val, best_a, best_Rn = val, a, Rn
        return best_a, best_Rn, best_val

    # ---------- Policy Evaluation ----------
    def evaluate(self, prices):
        T, M = prices.shape
        profits = np.zeros(M)
        C_day = self.daily_buy_cap()
        for m in range(M):
            R, B, total = 0.0, C_day, 0.0
            for t in range(T):
                p = prices[t, m]
                a, Rn, _ = self.decide(t, R, B, p)
                total += p * (max(-a, 0.0) - max(a, 0.0))
                R = Rn
                B = max(0.0, B - max(a, 0.0))
                if (t + 1) % self.day_len == 0:
                    B = C_day
            total += prices[-1, m] * R
            profits[m] = total
        return profits.mean(), profits

    # ---------- Deterministic schedule print ----------
    def print_schedule(self, base_curve, start_R=0.0):
        T = len(base_curve)
        R = float(start_R)
        B = self.daily_buy_cap()
        total = 0.0
        total_buy = 0.0
        total_sell = 0.0

        print("\nPolicy schedule along deterministic path:")
        print("t   Price    Action    Storage    Budget")
        for t in range(T):
            p = float(base_curve[t])
            a, Rn, _ = self.decide(t, R, B, p)
            total += p * (max(-a, 0.0) - max(a, 0.0))
            total_buy += max(a, 0.0)
            total_sell += max(-a, 0.0)
            Bn = max(0.0, B - max(a, 0.0))
            print(f"{t:02d}  {p:6.2f}   {a:7.2f}   {Rn:8.2f}   {Bn:8.2f}")
            R, B = Rn, Bn
            if (t + 1) % self.day_len == 0:
                B = self.daily_buy_cap()

        total += base_curve[-1] * R
        if R > 1e-9:
            print(f"** Terminal salvage of {R:.2f} at price {base_curve[-1]:.2f} adds {base_curve[-1]*R:.2f}")
        print(f"\nTotals â€” Buy: {total_buy:.2f}, Sell: {total_sell:.2f}, Profit: {total:.2f}")


# ---------- Run Example ----------
if __name__ == "__main__":
    rng = np.random.default_rng(42)
    T = 24
    base = np.array([40,38,36,35,34,33,32,35,45,55,60,70,
                     65,58,52,48,46,44,43,42,41,40,39,38], float)

    # In-sample (stochastic) and out-of-sample (deterministic)
    prices_train = generate_scenarios(T, 3000, rng, base, sigma=4.0, mean_revert=0.4)
    prices_test  = np.tile(base.reshape(-1, 1), (1, 1000))  # identical deterministic paths

    model = LSMC_Battery(
        T=T, R_max=100, eta_c=0.87,
        c_max=50, d_max=50, cycles=2,
        day_len=24, NR=21, NA=21, degree=3
    )

    model.fit(prices_train)
    mean_in, _      = model.evaluate(prices_train)
    mean_out, profs = model.evaluate(prices_test)

    print(f"\nIn-sample mean profit:  {mean_in:.2f}")
    print(f"Out-of-sample mean:     {mean_out:.2f}")
    print(f"Out-of-sample std:      {np.std(profs):.2f}")

    model.print_schedule(base)
